<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Holo Earth</title>

    <script src="https://cesium.com/downloads/cesiumjs/releases/1.130/Build/Cesium/Cesium.js"></script>
    <link href="https://cesium.com/downloads/cesiumjs/releases/1.130/Build/Cesium/Widgets/widgets.css" rel="stylesheet">

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body,
        html {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Courier New', Courier, monospace;
        }

        #cesiumContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* HUD Layer */
        #output_canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            /* transform: scaleX(-1); REMOVED: Handled by MediaPipe selfieMode */
        }

        /* Status HUD */
        #hud-status {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 20;
            color: #0ff;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border: 1px solid #0ff;
            border-radius: 8px;
            pointer-events: none;
        }

        .status-line {
            margin: 5px 0;
            font-size: 14px;
            text-shadow: 0 0 5px #0ff;
        }

        .highlight {
            color: #ff0055;
            font-weight: bold;
        }

        /* Center Crosshair */
        #center-crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 50;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        #center-crosshair::before,
        #center-crosshair::after {
            content: '';
            position: absolute;
            background: rgba(0, 255, 255, 0.6);
            /* Cyan semi-transparent */
            border-radius: 2px;
        }

        /* Horizontal line */
        #center-crosshair::before {
            top: 9px;
            left: 0;
            width: 100%;
            height: 2px;
        }

        /* Vertical line */
        #center-crosshair::after {
            top: 0;
            left: 9px;
            width: 2px;
            height: 100%;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #0ff;
            font-size: 24px;
            z-index: 30;
            text-shadow: 0 0 10px #0ff;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
        }

        .input_video {
            display: none;
        }

        .cesium-widget-credits {
            display: none !important;
        }
    </style>
</head>

<body>
    <video class="input_video"></video>
    <canvas id="output_canvas"></canvas>
    <div id="cesiumContainer"></div>
    <!-- Crosshair Element -->
    <div id="center-crosshair"></div>

    <div id="hud-status">
        <div class="status-line">SYSTEM: <span id="sys-status">INITIALIZING...</span></div>
        <div class="status-line">MODE: <span id="mode-status">IDLE</span></div>
        <div class="status-line">ALTITUDE: <span id="alt-status">Calculating...</span></div>
        <div class="status-line" style="font-size: 10px; color: #aaa; margin-top: 10px;">
            1 HAND PINCH = ROTATE<br>
            2 HANDS = ZOOM
        </div>
    </div>

    <div id="loading">Initializing Neural Link...<br><small>Please allow camera access</small></div>

    <script>
        // ==========================================================================================
        // 1. SETUP & KEYS (FILL THESE IN!)
        // ==========================================================================================

        // ‚ö†Ô∏è ËØ∑Âú®ËøôÈáåÂ°´ÂÖ•‰Ω†ÁöÑ Key
        const GOOGLE_MAPS_API_KEY = 'YOUR_GOOGLE_KEY_HERE1';
        Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIzOTRjMWZjNi04ZDViLTRkMzktYTU0Yy03YTg2YzhhMWI0NzAiLCJpZCI6Mzc3ODEzLCJpYXQiOjE3NjgyNTg0NjF9.w7XetoHHL8bzAWk5bIemKLlfpsRdWUcviM6xji1s5sE';

        // ‰∫§‰∫íÂèÇÊï∞ÂæÆË∞É
        const CONFIG = {
            PINCH_THRESHOLD: 0.05,    // ÊçèÂêàÁÅµÊïèÂ∫¶ (0.0-1.0)
            SMOOTHING: 0.15,          // Âπ≥ÊªëÁ≥ªÊï∞
            ROTATE_SPEED: 3.5,        // ÊóãËΩ¨ÈÄüÂ∫¶ (Radians per screen width)
            ZOOM_SPEED: 5.0           // Áº©ÊîæÈÄüÂ∫¶Âü∫Êï∞
        };

        // ==========================================================================================
        // 2. CESIUM ENGINE
        // ==========================================================================================

        const viewer = new Cesium.Viewer('cesiumContainer', {
            baseLayerPicker: false, geocoder: false, homeButton: false, infoBox: false,
            navigationHelpButton: false, sceneModePicker: false, selectionIndicator: false,
            timeline: false, animation: false, fullscreenButton: false, vrButton: false,
            skyAtmosphere: new Cesium.SkyAtmosphere()
        });

        viewer.scene.globe.enableLighting = true;
        viewer.scene.screenSpaceCameraController.minimumZoomDistance = 50; // ÈôêÂà∂Èº†Ê†áÁº©ÊîæÊúÄÂ∞èÈ´òÂ∫¶ (‰∏é onTick ‰øùÊåÅ‰∏ÄËá¥)
        viewer.scene.screenSpaceCameraController.zoomEventTypes = [Cesium.CameraEventType.WHEEL, Cesium.CameraEventType.PINCH];
        viewer.scene.screenSpaceCameraController.zoomFactor = 5.0; // ÊÅ¢Â§çÈªòËÆ§ÂÄº (5.0) ‰ª•Ëé∑ÂæóÊ≠£Â∏∏ÁöÑÁº©ÊîæÈÄüÂ∫¶

        // Âº∫Ë°åÈôêÂà∂Áõ∏Êú∫È´òÂ∫¶‰∏ç‰Ωé‰∫éÂú∞Èù¢ (Èò≤Ê≠¢Á©øÊ®°)
        viewer.clock.onTick.addEventListener(function () {
            const camera = viewer.camera;
            const pos = camera.positionCartographic;
            if (pos.height < 50) {
                // Â¶ÇÊûúÈ´òÂ∫¶‰Ωé‰∫é 50Á±≥ÔºåÂº∫Âà∂ÊãâÂõû 50Á±≥
                const newPos = Cesium.Cartesian3.fromRadians(pos.longitude, pos.latitude, 50);


                viewer.camera.setView({
                    destination: newPos,
                    orientation: {
                        heading: camera.heading,
                        pitch: camera.pitch,
                        roll: camera.roll
                    }
                });
            }
        });

        // Âä†ËΩΩ Google 3D Tiles & Âè†Âä†ÈÅìË∑Ø (Cesium 1.130+)
        async function loadTileset() {
            if (!GOOGLE_MAPS_API_KEY == 'YOUR_GOOGLE_KEY') {
                alert("ËØ∑Âú®‰ª£Á†Å‰∏≠Â°´ÂÖ• Google Maps API Key ÊâçËÉΩÊòæÁ§∫ÁúüÂÆûÂüéÂ∏ÇÊ®°ÂûãÔºÅ");
                return;
            }
            try {
                Cesium.GoogleMaps.defaultApiKey = GOOGLE_MAPS_API_KEY;
                const tileset = await Cesium.createGooglePhotorealistic3DTileset();
                viewer.scene.primitives.add(tileset);

                // üåü Âè†Âä†ÈÅìË∑ØÂ±Ç (Hybrid)
                // ‰ΩøÁî® Bing Maps AerialWithLabels (Asset ID 3) Ë¶ÜÁõñÂú® 3D Tiles ‰∏ä
                const roadLayer = await Cesium.IonImageryProvider.fromAssetId(3);
                tileset.imageryLayers.addImageryProvider(roadLayer);

            } catch (e) {
                console.error(e);
                document.getElementById('sys-status').innerText = "MAP LOAD FAILED";
            }
        }
        loadTileset();

        // ÂàùÂßãËßÜËßí (‰∏äÊµ∑)
        // ÂàùÂßãËßÜËßí (‰∏äÊµ∑ - ÂûÇÁõ¥‰øØËßÜÔºåÈîÅÂÆöÁêÉÂøÉ)
        // ‰ΩøÁî® lookAt ÈîÅÂÆöÂú∞ÁêÉ‰∏≠ÂøÉÔºåÁ°Æ‰øùÊóãËΩ¨ÊòØÂõ¥ÁªïÁêÉÂøÉÁöÑ
        const initialPos = Cesium.Cartesian3.fromDegrees(31.2304, 31.2304, 20000000); // 20000km È´òÁ©∫ÔºåÁúãÂÖ®Âú∞ÁêÉ
        viewer.camera.lookAt(Cesium.Cartesian3.ZERO, initialPos);

        // ËæÖÂä©ÂáΩÊï∞ÔºöËÆ°ÁÆóÊçèÂêàË∑ùÁ¶ª
        function calculatePinchDist(hand) {
            const thumb = hand[4];
            const index = hand[8];
            return Math.hypot(thumb.x - index.x, thumb.y - index.y);
        }

        // ËæÖÂä©ÂáΩÊï∞ÔºöÊ†πÊçÆÈ´òÂ∫¶Ëé∑ÂèñÁÅµÊïèÂ∫¶ (ÂØπ‰∫éÊóãËΩ¨Ê®°ÂºèÔºåÂÖ∂ÂÆû‰∏ªË¶ÅÊòØËßíÂ∫¶ÔºåÈ´òÂ∫¶ÂΩ±ÂìçËæÉÂ∞èÔºå‰ΩÜ‰øùÁïôÊé•Âè£)
        // ËæÖÂä©ÂáΩÊï∞ÔºöÊ†πÊçÆÈ´òÂ∫¶Ëé∑ÂèñÁÅµÊïèÂ∫¶ (ÂØπ‰∫éÊóãËΩ¨Ê®°ÂºèÔºåÂÖ∂ÂÆû‰∏ªË¶ÅÊòØËßíÂ∫¶ÔºåÈ´òÂ∫¶ÂΩ±ÂìçËæÉÂ∞èÔºå‰ΩÜ‰øùÁïôÊé•Âè£)
        function getDynamicSensitivity() {
            // Ê†∏ÂøÉ‰øÆÊ≠£ÔºöÁº©ÊîæË∂äËøëÔºåÈúÄË¶ÅÁöÑÊóãËΩ¨ËßíÂ∫¶Ë∂äÂ∞èÊâçËÉΩËææÂà∞‚ÄúÊãñÊãΩÂú∞Èù¢‚ÄùÁöÑÊÑüËßâ
            // Â¶ÇÊûúËßíÂ∫¶ÊÅíÂÆöÔºå‰ΩéÁ©∫Êó∂Âú∞Èù¢ÁßªÂä®ÈÄüÂ∫¶‰ºöËøáÂø´ÔºàÁû¨Èó¥È£ûËøáÂüéÂ∏ÇÔºâ
            // ‰ΩÜÁî®Êà∑ÂèçÈ¶à‚ÄúÊóãËΩ¨Ë∂äÂ∞è‚ÄùÔºåÂèØËÉΩÊòØÂõ†‰∏∫Ê≤°ÊúâÊ≠£Á°Æ Orbit ÂØºËá¥ÂéüÂú∞ÊâìËΩ¨
            // ËøôÈáåÊàë‰ª¨ÊÅ¢Â§çÈ´òÂ∫¶Áº©ÊîæÔºåÁ°Æ‰øù 1:1 ÊãñÊãΩÊÑü
            const height = viewer.camera.positionCartographic.height;
            const EARTH_RADIUS = 6371000;
            // Âü∫Á°ÄÈÄüÂ∫¶ * (È´òÂ∫¶ / Âú∞ÁêÉÂçäÂæÑ)
            // È´òÁ©∫ (20000km) -> Ratio ~3 -> Speed ~10
            // ‰ΩéÁ©∫ (100m) -> Ratio ~1.5e-5 -> Speed ~Tiny
            // ËøôÊ†∑‰øùËØÅ‰∫ÜÂú∞Èù¢ÁßªÂä®Ë∑ùÁ¶ª‰∏éÊâãÊåáÁßªÂä®Ë∑ùÁ¶ªÂ§ßËá¥ÊàêÊ≠£ÊØî
            return CONFIG.ROTATE_SPEED * (height * 0.5 / EARTH_RADIUS);
        }

        // ==========================================================================================
        // 2.5 CUSTOM MOUSE CONTROLS (With Dynamic Sensitivity)
        // ==========================================================================================

        const crosshair = document.getElementById('center-crosshair');
        function setCrosshairVisible(visible) {
            crosshair.style.opacity = visible ? '1' : '0';
        }

        // ÊÅ¢Â§çÈªòËÆ§ÁöÑÊóãËΩ¨ (Left Drag)
        viewer.scene.screenSpaceCameraController.enableRotate = true;

        const handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
        let isMouseDragging = false;

        handler.setInputAction(function (movement) {
            isMouseDragging = true;
            setCrosshairVisible(true);
        }, Cesium.ScreenSpaceEventType.LEFT_DOWN);

        handler.setInputAction(function (movement) {
            isMouseDragging = false;
            setCrosshairVisible(false);
        }, Cesium.ScreenSpaceEventType.LEFT_UP);

        // Also handle zoom start/end for mouse wheel if possible, but Cesium doesn't expose clean start/end events for wheel.
        // We can use a timeout for wheel.
        let wheelTimeout;
        handler.setInputAction(function (movement) {
            setCrosshairVisible(true);
            clearTimeout(wheelTimeout);
            wheelTimeout = setTimeout(() => {
                if (!isMouseDragging && !isPinching) {
                    setCrosshairVisible(false);
                }
            }, 500); // 500ms after last scroll, hide
        }, Cesium.ScreenSpaceEventType.WHEEL);


        // ==========================================================================================
        // 3. MEDIAPIPE LOGIC
        // ==========================================================================================

        const videoElement = document.getElementsByClassName('input_video')[0];
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');

        // UI Elements
        const uiSys = document.getElementById('sys-status');
        const uiMode = document.getElementById('mode-status');
        const uiAlt = document.getElementById('alt-status');
        const uiLoad = document.getElementById('loading');

        // State Variables
        let lastHandPos = null;   // {x, y}
        let lastPinchDist = null; // float
        let isPinching = false;

        // Smooth State
        let smoothX = 0, smoothY = 0;

        // Reset state helper
        function resetState(statusText) {
            isPinching = false;
            lastHandPos = null;
            lastPinchDist = null;
            uiMode.innerText = statusText;
            uiMode.className = "";

            // Should hide crosshair if not mouse dragging
            if (!isMouseDragging) {
                setCrosshairVisible(false);
            }
        }

        // Single Hand Rotation Logic
        function handleRotation(hand) {
            isPinching = true;
            uiMode.innerText = "GRABBING (PAN)";
            uiMode.className = "highlight";
            setCrosshairVisible(true);

            const thumb = hand[4];
            const index = hand[8];
            const cx = (thumb.x + index.x) / 2;
            const cy = (thumb.y + index.y) / 2;

            // Smooth State Initialization
            if (lastHandPos === null) {
                smoothX = cx; smoothY = cy;
            } else {
                smoothX = smoothX * (1 - CONFIG.SMOOTHING) + cx * CONFIG.SMOOTHING;
                smoothY = smoothY * (1 - CONFIG.SMOOTHING) + cy * CONFIG.SMOOTHING;
            }

            if (lastHandPos) {
                const deltaX = smoothX - lastHandPos.x;
                const deltaY = smoothY - lastHandPos.y;

                if (Math.hypot(deltaX, deltaY) > 0.001) {
                    const sensitivity = getDynamicSensitivity();

                    // X-axis: Earth rotates L/R -> Camera rotates R/L
                    const rotateX = Math.abs(deltaX) * sensitivity;
                    if (deltaX > 0) viewer.camera.rotateLeft(rotateX);
                    else viewer.camera.rotateRight(rotateX);

                    // Y-axis: Earth rotates Up/Down -> Camera rotates Down/Up
                    const rotateY = Math.abs(deltaY) * sensitivity;
                    if (deltaY > 0) viewer.camera.rotateDown(rotateY);
                    else viewer.camera.rotateUp(rotateY);
                }
            }

            lastHandPos = { x: smoothX, y: smoothY };
            lastPinchDist = null; // Reset zoom state
        }

        // Dual Hand Zoom Logic
        function handleZoom(h1, h2) {
            uiMode.innerText = "ZOOMING (DUAL PINCH)";
            uiMode.className = "highlight";
            isPinching = true;
            setCrosshairVisible(true);
            lastHandPos = null; // Reset rotation state

            // Calculate distance between centers of hands (using index 9: Middle Finger MCP)
            const c1 = h1[9];
            const c2 = h2[9];
            const currDist = Math.hypot(c1.x - c2.x, c1.y - c2.y);

            if (lastPinchDist) {
                const delta = currDist - lastPinchDist;

                if (Math.abs(delta) > 0.002) {
                    const zoomAmount = delta * viewer.camera.positionCartographic.height * CONFIG.ZOOM_SPEED;

                    if (delta > 0) {
                        viewer.camera.zoomIn(zoomAmount);
                    } else {
                        viewer.camera.zoomOut(Math.abs(zoomAmount));
                    }
                }
            }
            lastPinchDist = currDist;
        }

        function onResults(results) {
            uiLoad.style.display = 'none';
            uiSys.innerText = "ONLINE";

            // Update Altitude
            const height = viewer.camera.positionCartographic.height;
            uiAlt.innerText = Math.round(height) + " m";

            // Prepare Canvas
            canvasElement.width = videoElement.videoWidth;
            canvasElement.height = videoElement.videoHeight;
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const hands = results.multiHandLandmarks;

                // Draw Skeletons
                for (const landmarks of hands) {
                    const dist = calculatePinchDist(landmarks);
                    const color = (dist < CONFIG.PINCH_THRESHOLD) ? '#FF0055' : '#00FFFF';
                    drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, { color: color, lineWidth: 2 });
                    drawLandmarks(canvasCtx, landmarks, { color: '#FFFFFF', lineWidth: 1, radius: 3 });
                }

                // ---------------------------------------------------------
                // Interaction Logic
                // ---------------------------------------------------------

                // Filter hands that are pinching
                let pinchingHands = [];
                for (const h of hands) {
                    if (calculatePinchDist(h) < CONFIG.PINCH_THRESHOLD) {
                        pinchingHands.push(h);
                    }
                }

                if (pinchingHands.length >= 2) {
                    // Case: At least 2 hands pinching -> ZOOM
                    handleZoom(pinchingHands[0], pinchingHands[1]);

                } else if (pinchingHands.length === 1) {
                    // Case: Exactly 1 hand pinching -> ROTATE (Move)
                    // This works whether there is 1 hand total or 2 hands total
                    handleRotation(pinchingHands[0]);

                } else {
                    // Case: No hands pinching
                    if (hands.length >= 2) {
                        resetState("WAITING (2 HANDS)");
                    } else {
                        resetState("HOVERING");
                    }
                }

            } else {
                // No hands detected
                resetState("IDLE");
            }
        }

        // ÂàùÂßãÂåñ MediaPipe
        const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
        hands.setOptions({
            selfieMode: true, // ÂºÄÂêØËá™ÊãçÈïúÂÉèÊ®°Âºè
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        hands.onResults(onResults);

        const camera = new Camera(videoElement, {
            onFrame: async () => { await hands.send({ image: videoElement }); },
            width: 1280, height: 720
        });
        camera.start();
    </script>
</body>

</html>